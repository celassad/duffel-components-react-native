/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import axios from 'axios';
/**
 * An object containing metadata about the service, like the designator of the seat
 */
export interface OrderServiceMetadataSeat {
  designator: string;
  name: string;
  disclosures: string[];
}

export type SelectedService = {
  service: Service;
  quantity: number;
};

export type DuffelApiModelsOrderOrderServiceMetadata =
  | OrderServiceMetadataSeat
  | OrderServiceMetadataBaggage;

/**
 * The service booked along with this order
 */
export interface DuffelApiModelsOrderOrderService {
  id: string;
  metadata: DuffelApiModelsOrderOrderServiceMetadata;
  passenger_ids: string[];
  quantity: number;
  segment_ids: string[];
  total_amount: string;
  total_currency: string;
  type: string;
}

export type _TypesDuffelApiSearchInputPassengers =
  RootModelUnionPassengerWithAgePassengerWithType[];

export interface _TypesDuffelApiSearchInputData {
  slices: Slices;
  passengers: _TypesDuffelApiSearchInputPassengers;
  /** The cabin that the passengers want to travel in. */
  cabin_class: CabinClass;
  /** The maximum number of connections within any slice of the offer. For example 0 means a direct flight which will have a single segment within each slice and 1 means a maximum of two segments within each slice of the offer. */
  max_connections?: number;
}

export type _TypesDuffelApiGetPartialOfferInputDataSelectedPartialOffers =
  | string[]
  | null;

export interface _TypesDuffelApiGetPartialOfferInputData {
  id?: string;
  selected_partial_offers?: _TypesDuffelApiGetPartialOfferInputDataSelectedPartialOffers;
}

export type _TypesDuffelApiCreateOrderInputPassengers = Passenger[];

export interface _TypesDuffelApiCreateOrderInputOrderService {
  /** The id of the service from the offer's available_services that you want to book */
  id: string;
  /** The quantity of the service to book. This will always be 1 for seat services. */
  quantity: number;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type SortValue = (typeof SortValue)[keyof typeof SortValue];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SortValue = {
  'total_amount': 'total_amount',
  'total_duration': 'total_duration',
  '-total_amount': '-total_amount',
  '-total_duration': '-total_duration',
} as const;

/**
 * The inclusive time range for the arrival of the slice
 */
export type SliceArrivalTime = ArrivalTimeRange | null;

/**
 * The inclusive time range for the departure of the slice
 */
export type SliceDepartureTime = DepartureTimeRange | null;

export interface Slice {
  /** The 3-letter IATA code for the city or airport where this slice starts */
  origin: string;
  /** The 3-letter IATA code for the city or airport where this slice ends */
  destination: string;
  /** The ISO 8601 date on which the passengers want to depart */
  departure_date: string;
  /** The inclusive time range for the departure of the slice */
  departure_time?: SliceDepartureTime;
  /** The inclusive time range for the arrival of the slice */
  arrival_time?: SliceArrivalTime;
}

export type Slices = Slice[];

export type ServiceMetadataMaximumDepthCm = number | null;

export type ServiceMetadataMaximumLengthCm = number | null;

export type ServiceMetadataMaximumHeightCm = number | null;

export type ServiceMetadataMaximumWeightKg = number | null;

export type ServiceMetadataType = string | null;

/**
 * An object containing metadata about the service, like the maximum weight
    and dimensions of the baggage.
    
 */
export interface ServiceMetadata {
  type?: ServiceMetadataType;
  maximum_weight_kg?: ServiceMetadataMaximumWeightKg;
  maximum_height_cm?: ServiceMetadataMaximumHeightCm;
  maximum_length_cm?: ServiceMetadataMaximumLengthCm;
  maximum_depth_cm?: ServiceMetadataMaximumDepthCm;
}

/**
 * The services that can be booked with the offer but are not included by default,
    for example an additional checked bag. This field is only returned in the [Get single
    offer](https://duffel.com/docs/api/offers/get-offer-by-id) endpoint. When there are no
    services available, or we don't support services for the airline, this list will be
    empty. If you want to know which airlines we support services for, please get in touch
    with the Duffel support team at help@duffel.com.
    
 */
export interface Service {
  id: string;
  maximum_quantity: number;
  metadata: ServiceMetadata;
  passenger_ids: string[];
  segment_ids: string[];
  total_amount: string;
  total_currency: string;
  type: string;
}

export interface SearchPlacesNameInput {
  /** A search string for finding matching Places by name */
  name: string;
}

export interface SearchPlacesCoordinatesInput {
  /** The latitude to search by */
  lat: number;
  /** The longitude to search by */
  lng: number;
  /** The (int) radius, in metres, to search within. 10.0km by default. */
  rad?: number;
}

export type SearchPlacesInput =
  | SearchPlacesNameInput
  | SearchPlacesCoordinatesInput;

export interface SearchInput {
  /** To search for flights, you'll need to create an offer request. An offer request describes the passengers and where and when they want to travel (in the form of a list of slices). It may also include additional filters (e.g. a particular cabin to travel in). */
  data: _TypesDuffelApiSearchInputData;
}

export type SearchAirportInputWithPaginationPagination = PaginationInput | null;

export interface SearchAirportInputWithPagination {
  pagination?: SearchAirportInputWithPaginationPagination;
  /** Retrieves a list of Places whose airport/city/country name or IATA code match the provided query or are within a radius of a location */
  request: SearchAirportInput;
}

/**
 * The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section.
 */
export type SearchAirportInputLimit = number | null;

export interface SearchAirportInput {
  /** The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section. */
  limit?: SearchAirportInputLimit;
  /** Filters the returned airports by their iata_country_code - see the iata_country_code parameter in the Airport schema for details */
  iata_country_code: string;
}

export type RootModelUnionPassengerWithAgePassengerWithType =
  | PassengerWithAge
  | PassengerWithType;

export interface RootModelDictAnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength40PydanticGeneralMetadataPatternAZAZ09AnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength500 {
  [key: string]: any;
}

export interface UpdateOrderInput {
  /** Metadata contains a set of key-value pairs that you can attach to an object. It can be useful for storing additional information about the object, in a structured format. Duffel does not use this information. You should not store sensitive information in this field.

The metadata is a collection of key-value pairs, both of which are strings. You can store a maximum of 50 key-value pairs, where each key has a maximum length of 40 characters and each value has a maximum length of 500 characters.

Keys must only contain numbers, letters, dashes, or underscores.

To clear this field, set it to an empty object ({}). */
  metadata?: RootModelDictAnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength40PydanticGeneralMetadataPatternAZAZ09AnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength500;
}

export type RefundNetCurrency = string | null;

export type RefundNetAmount = string | null;

/**
 * A Refund allows you to refund money that you had collected from a customer with a
    Payment Intent. You're able to do partial refunds and also able to do multiple
    refunds for the same Payment Intent.
    
 */
export interface Refund {
  id: string;
  live_mode: boolean;
  payment_intent_id: string;
  amount: string;
  currency: string;
  net_amount?: RefundNetAmount;
  net_currency?: RefundNetCurrency;
  status: string;
  destination: string;
  arrival: string;
  created_at: string;
  updated_at: string;
}

export interface ProgrammeAccount {
  /** The passenger's account number for this loyalty programme account */
  account_number: string;
  /** The IATA code for the airline that this loyalty programme account belongs to */
  airline_iata_code: string;
}

export type PlaceAirports = Airport[] | null;

export type PlaceCity = City | null;

export type PlaceCityName = string | null;

export type PlaceTimeZone = string | null;

export type PlaceIcaoCode = string | null;

export type PlaceLongitude = number | null;

export type PlaceLatitude = number | null;

export type PlaceIataCityCode = string | null;

/**
 * The city or airport
 */
export interface Place {
  id: string;
  name: string;
  type: string;
  iata_city_code?: PlaceIataCityCode;
  iata_country_code: string;
  latitude?: PlaceLatitude;
  longitude?: PlaceLongitude;
  icao_code?: PlaceIcaoCode;
  time_zone?: PlaceTimeZone;
  city_name?: PlaceCityName;
  city?: PlaceCity;
  airports?: PlaceAirports;
}

export type Places = Place[];

export type Payments = Payment[];

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentType = {
  arc_bsp_cash: 'arc_bsp_cash',
  balance: 'balance',
} as const;

export type PaymentRequirementsPriceGuaranteeExpiresAt = string | null;

export type PaymentRequirementsPaymentRequiredBy = string | null;

/**
 * The payment requirements for an offer
 */
export interface PaymentRequirements {
  payment_required_by?: PaymentRequirementsPaymentRequiredBy;
  price_guarantee_expires_at?: PaymentRequirementsPriceGuaranteeExpiresAt;
  requires_instant_payment: boolean;
}

export type PaymentIntentConfirmedAt = string | null;

export type PaymentIntentCardCountryCode = string | null;

export type PaymentIntentCardLastFourDigits = string | null;

export type PaymentIntentCardNetwork = string | null;

export type PaymentIntentFeesCurrency = string | null;

export type PaymentIntentFeesAmount = string | null;

export type PaymentIntentNetCurrency = string | null;

export type PaymentIntentNetAmount = string | null;

/**
 * To begin the process of collecting a card payment from your customer, you
    need to create a Payment Intent.

    The Payment Intent will contain a client_token that you use to collect the
    card payment in your application.

    If the Payment Intent is created in test mode you should use a test card.
    
 */
export interface PaymentIntent {
  id: string;
  live_mode: boolean;
  amount: string;
  currency: string;
  net_amount?: PaymentIntentNetAmount;
  net_currency?: PaymentIntentNetCurrency;
  fees_amount?: PaymentIntentFeesAmount;
  fees_currency?: PaymentIntentFeesCurrency;
  client_token: string;
  card_network?: PaymentIntentCardNetwork;
  card_last_four_digits?: PaymentIntentCardLastFourDigits;
  card_country_code?: PaymentIntentCardCountryCode;
  status: string;
  refunds: Refund[];
  confirmed_at?: PaymentIntentConfirmedAt;
  created_at: string;
  updated_at: string;
}

export interface Payment {
  /** The amount of the payment. This should be the same as the total_amount of the offer specified in selected_offers, plus the total_amount of all the services specified in services. */
  amount: string;
  /** The currency of the amount, as an ISO 4217 currency code. This should be the same as the total_currency of the offer specified in selected_offers. The first two letters of the ISO 4217 three-letter code are the same as the code for the country name, and, where possible, the third letter corresponds to the first letter of the currency name */
  currency: string;
  /** The type of payment you want to apply to the order. If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying arc_bsp_cash. Otherwise, you must pay using your Duffel account's balance by specifying balance. In test mode, your balance is unlimited. If you're not sure which of these options applies to you, get in touch with the Duffel support team at help@duffel.com. */
  type: PaymentType;
}

/**
 * The loyalty programme accounts for this passenger
 */
export type PassengerWithTypeLoyaltyProgrammeAccounts =
  | ProgrammeAccount[]
  | null;

/**
 * The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts.
 */
export type PassengerWithTypeGivenName = string | null;

/**
 * The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts.
 */
export type PassengerWithTypeFamilyName = string | null;

export interface PassengerWithType {
  /** The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts. */
  family_name?: PassengerWithTypeFamilyName;
  /** The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts. */
  given_name?: PassengerWithTypeGivenName;
  /** The loyalty programme accounts for this passenger */
  loyalty_programme_accounts?: PassengerWithTypeLoyaltyProgrammeAccounts;
  /** The type of the passenger. If the passenger is aged 18 or over, you should specify a type of adult. If a passenger is aged under 18, you should specify their age instead of a type. A passenger can have only a type or an age, but not both. */
  type: PassengerType;
}

/**
 * The loyalty programme accounts for this passenger
 */
export type PassengerWithAgeLoyaltyProgrammeAccounts =
  | ProgrammeAccount[]
  | null;

/**
 * The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts.
 */
export type PassengerWithAgeGivenName = string | null;

/**
 * The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts.
 */
export type PassengerWithAgeFamilyName = string | null;

export interface PassengerWithAge {
  /** The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts. */
  family_name?: PassengerWithAgeFamilyName;
  /** The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.

This is only required if you're also including loyalty programme accounts. */
  given_name?: PassengerWithAgeGivenName;
  /** The loyalty programme accounts for this passenger */
  loyalty_programme_accounts?: PassengerWithAgeLoyaltyProgrammeAccounts;
  /** The age of the passenger on the departure_date of the final slice. e.g. if you a searching for a round trip and the passenger is 15 years old at the time of the outbound flight, but they then have their birthday and are 16 years old for the inbound flight, you must set the age to 16. You should specify an age for passengers who are under 18 years old. A passenger can have only a type or an age, but not both. You can optionally pass age with fare_type though. */
  age: number;
}

export type PassengerType = (typeof PassengerType)[keyof typeof PassengerType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PassengerType = {
  adult: 'adult',
  child: 'child',
  infant_without_seat: 'infant_without_seat',
} as const;

export type PassengerTitle =
  (typeof PassengerTitle)[keyof typeof PassengerTitle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PassengerTitle = {
  mr: 'mr',
  ms: 'ms',
  mrs: 'mrs',
  miss: 'miss',
  dr: 'dr',
} as const;

/**
 * Infant passengers, with an age of 0 or 1, must be associated with an adult passenger. This field should be used to make this association. It should contain the id of the infant passenger as returned in the offer request.
 */
export type PassengerInfantPassengerId = string | null;

/**
 * The passenger's identity documents. You may only provide one identity document per type per passenger. The identity document's type supported by the airline can be found in the offer's supported_passenger_identity_document_types. If the offer's passenger_identity_documents_required is set to true, then a passport document must be provided.
 */
export type PassengerIdentityDocuments = IdDocument[] | null;

/**
 * The passenger's date of birth
 */
export type PassengerBornOn = string | null;

export interface Passenger {
  /** The passenger's date of birth */
  born_on?: PassengerBornOn;
  /** The passenger's email address */
  email: string;
  /** The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 or 2 characters, and the maximum, combined with given_name, is 40 characters. The requirements vary by airline. We recommend using a minimum length of 2. */
  family_name: string;
  /** The passenger's gender */
  gender: Gender;
  /** The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of √Ü, √¶, ƒ≤, ƒ≥, ≈í, ≈ì, √û, and √∞) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 or 2 characters, and the maximum, combined with family_name, is 40 characters. The requirements vary by airline. We recommend using a minimum length of 2. */
  given_name: string;
  /** The id of the passenger, returned when the offer request was created */
  id: string;
  /** The passenger's identity documents. You may only provide one identity document per type per passenger. The identity document's type supported by the airline can be found in the offer's supported_passenger_identity_document_types. If the offer's passenger_identity_documents_required is set to true, then a passport document must be provided. */
  identity_documents: PassengerIdentityDocuments;
  /** Infant passengers, with an age of 0 or 1, must be associated with an adult passenger. This field should be used to make this association. It should contain the id of the infant passenger as returned in the offer request. */
  infant_passenger_id?: PassengerInfantPassengerId;
  /** The passenger's phone number in E.164 (international) format */
  phone_number: string;
  /** The passenger's title (the dr title is not supported by certain airlines, where a ValidationError will be returned instead if used) */
  title: PassengerTitle;
}

export type PaginationMetadataBefore = string | null;

export type PaginationMetadataAfter = string | null;

export interface PaginationMetadata {
  limit: number;
  after?: PaginationMetadataAfter;
  before?: PaginationMetadataBefore;
}

export interface PaginationInputBefore {
  /** A cursor pointing to the next page of records. For more information on how to paginate through records, see the Pagination section. */
  before: string;
}

export interface PaginationInputAfter {
  /** A cursor pointing to the previous page of records. For more information on how to paginate through records, see the Pagination section. */
  after: string;
}

export type PaginationInput =
  | PaginationInputBefore
  | PaginationInputAfter
  | null;

export type PaginatedResultOrderMeta = PaginationMetadata | null;

export interface PaginatedResultOrder {
  data: Order[];
  meta: PaginatedResultOrderMeta;
}

export type PaginatedResultOfferMeta = PaginationMetadata | null;

export interface PaginatedResultOffer {
  data: Offer[];
  meta: PaginatedResultOfferMeta;
}

export type PaginatedResultAirportMeta = PaginationMetadata | null;

export interface PaginatedResultAirport {
  data: Airport[];
  meta: PaginatedResultAirportMeta;
}

export type OrderType = (typeof OrderType)[keyof typeof OrderType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderType = {
  instant: 'instant',
  hold: 'hold',
} as const;

/**
 * An object containing metadata about the service, like the designator of the seat
 */
export interface OrderSliceSegmentPassengerSeat {
  designator: string;
  name: string;
  disclosures: string[];
}

/**
 * The baggage allowances for the passenger on this segment that were included in the
    original offer. Any extra baggage items which were booked as services will be listed
    in the services field instead of here.
    
 */
export interface OrderSliceSegmentPassengerBaggage {
  type: string;
  quantity: number;
}

export type OrderSliceSegmentPassengerSeatProperty =
  OrderSliceSegmentPassengerSeat | null;

/**
 * Additional segment-specific information about the passengers included in the offer
    (e.g. their baggage allowance and the cabin class they will be travelling in)
    
 */
export interface OrderSliceSegmentPassenger {
  baggages: OrderSliceSegmentPassengerBaggage[];
  cabin_class: string;
  cabin_class_marketing_name: string;
  passenger_id: string;
  seat?: OrderSliceSegmentPassengerSeatProperty;
}

export type OrderSliceSegmentOperatingCarrierFlightNumber = string | null;

export type OrderSliceSegmentDuration = string | null;

export type OrderSliceSegmentDistance = string | null;

export type OrderSliceSegmentOriginTerminal = string | null;

export type OrderSliceSegmentDestinationTerminal = string | null;

export type OrderSliceSegmentAircraft = Aircraft | null;

/**
 * The segments - that is, specific flights - that the airline is offering to get the
    passengers from the `origin` to the `destination`
    
 */
export interface OrderSliceSegment {
  id: string;
  aircraft?: OrderSliceSegmentAircraft;
  arriving_at: string;
  departing_at: string;
  destination: Airport;
  destination_terminal?: OrderSliceSegmentDestinationTerminal;
  origin: Airport;
  origin_terminal?: OrderSliceSegmentOriginTerminal;
  distance?: OrderSliceSegmentDistance;
  duration?: OrderSliceSegmentDuration;
  marketing_carrier: Airline;
  marketing_carrier_flight_number: string;
  operating_carrier: Airline;
  operating_carrier_flight_number?: OrderSliceSegmentOperatingCarrierFlightNumber;
  passengers: OrderSliceSegmentPassenger[];
}

export type OrderSliceConditionsChangeBeforeDeparture =
  OrderSliceConditionChangeBeforeDeparture | null;

/**
 * The conditions associated with this slice, describing the kinds of
    modifications you can make and any penalties that
    will apply to those modifications.

    This condition is applied only to this slice and to all the passengers
    associated with this order - for information at the order level
    (e.g. "what happens if I want to change all the slices?") refer to the
    `conditions` at the top level.

    If a particular kind of modification is allowed, you may not always be able to take
    action through the Duffel API. In some cases, you may need to contact the Duffel
    support team or
    the airline directly.
    
 */
export interface OrderSliceConditions {
  change_before_departure?: OrderSliceConditionsChangeBeforeDeparture;
}

export type OrderSliceConditionChangeBeforeDeparturePenaltyCurrency =
  | string
  | null;

export type OrderSliceConditionChangeBeforeDeparturePenaltyAmount =
  | string
  | null;

/**
 * Whether this slice can be changed before the departure.

    If the slice can be changed for all of the passengers then
    the `allowed` property will be `true` and information will be
    provided about any penalties.

    If none of the passengers on the slice can be changed then
    the `allowed` property will be `false`.

    In all other cases this property will be `null` indicating we
    can't provide the information for this slice.

    The `penalty_amount` is specific to changing this slice and may not be
    the penalties that is applied if the entire order is changed.
    
 */
export interface OrderSliceConditionChangeBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OrderSliceConditionChangeBeforeDeparturePenaltyAmount;
  penalty_currency?: OrderSliceConditionChangeBeforeDeparturePenaltyCurrency;
}

export type OrderSliceDuration = string | null;

/**
 * A slice is one part of the slices that make up the itinerary of an order.
    One-way journeys can be expressed using one slice, whereas return trips will need two.
    
 */
export interface OrderSlice {
  id: string;
  changeable: boolean;
  destination_type: string;
  destination: Place;
  origin_type: string;
  origin: Place;
  duration?: OrderSliceDuration;
  segments: OrderSliceSegment[];
  conditions: OrderSliceConditions;
}

export type OrderServices = _TypesDuffelApiCreateOrderInputOrderService[];

export type OrderServiceMetadataBaggageMaximumDepthCm = number | null;

export type OrderServiceMetadataBaggageMaximumLengthCm = number | null;

export type OrderServiceMetadataBaggageMaximumHeightCm = number | null;

export type OrderServiceMetadataBaggageMaximumWeightKg = number | null;

/**
 * An object containing metadata about the service, like the maximum weight and
    dimensions of the baggage.
    
 */
export interface OrderServiceMetadataBaggage {
  type: string;
  maximum_weight_kg?: OrderServiceMetadataBaggageMaximumWeightKg;
  maximum_height_cm?: OrderServiceMetadataBaggageMaximumHeightCm;
  maximum_length_cm?: OrderServiceMetadataBaggageMaximumLengthCm;
  maximum_depth_cm?: OrderServiceMetadataBaggageMaximumDepthCm;
}

export type OrderPaymentStatusPriceGuaranteeExpiresAt = string | null;

export type OrderPaymentStatusPaymentRequiredBy = string | null;

/**
 * The payment status for an order
 */
export interface OrderPaymentStatus {
  awaiting_payment: boolean;
  payment_required_by?: OrderPaymentStatusPaymentRequiredBy;
  price_guarantee_expires_at?: OrderPaymentStatusPriceGuaranteeExpiresAt;
}

export type OrderPassengerBornOn = string | null;

export type OrderPassengerInfantPassengerId = string | null;

/**
 * A passenger who is travelling
 */
export interface OrderPassenger {
  id: string;
  type: string;
  infant_passenger_id?: OrderPassengerInfantPassengerId;
  given_name: string;
  family_name: string;
  gender: string;
  title: string;
  born_on?: OrderPassengerBornOn;
  loyalty_programme_accounts: LoyaltyProgrammeAccount[];
}

/**
 * A document issued for this order.
 */
export interface OrderDocument {
  type: string;
  unique_identifier: string;
}

export type OrderConditionsRefundBeforeDeparture =
  OrderConditionRefundBeforeDeparture | null;

export type OrderConditionsChangeBeforeDeparture =
  OrderConditionChangeBeforeDeparture | null;

/**
 * The conditions associated with this order, describing the kinds of
    modifications you can make to it and any penalties that
    will apply to those modifications.

    This information assumes the condition is applied to all of the slices and passengers
    associated with this order - for information at the slice level
    (e.g. "what happens if I just want to change the first slice?") refer to the `slices`.

    If a particular kind of modification is allowed, you may not always be able to take
    action through the Duffel API. In some cases, you may need to contact the Duffel
    support team or the airline directly.
    
 */
export interface OrderConditions {
  change_before_departure?: OrderConditionsChangeBeforeDeparture;
  refund_before_departure?: OrderConditionsRefundBeforeDeparture;
}

export type OrderConditionRefundBeforeDeparturePenaltyCurrency = string | null;

export type OrderConditionRefundBeforeDeparturePenaltyAmount = string | null;

/**
 * Whether the whole order can be refunded before the departure of the first slice.

    If all of the slices on the order can be refunded then
    the `allowed` property will be `true` and information will be
    provided about any penalties.

    If any of the slices on the order can't be refunded then
    the `allowed` property will be `false`.

    If the airline hasn't provided any information about whether
    this order can be refunded then this property will be `null`.
    
 */
export interface OrderConditionRefundBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OrderConditionRefundBeforeDeparturePenaltyAmount;
  penalty_currency?: OrderConditionRefundBeforeDeparturePenaltyCurrency;
}

export type OrderConditionChangeBeforeDeparturePenaltyCurrency = string | null;

export type OrderConditionChangeBeforeDeparturePenaltyAmount = string | null;

/**
 * Whether the whole order can be changed before the departure of the first slice.

    If all of the slices on the order can be changed then
    the `allowed` property will be `true`. Refer to the `slices` for
    information about change penalties.

    If any of the slices on the order can't be changed then
    the `allowed` property will be `false`. In this case you should
    refer to the `slices` conditions to determine if any part
    of the order is changeable.

    If the airline hasn't provided any information about whether
    this order can be changed then this property will be `null`.
    
 */
export interface OrderConditionChangeBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OrderConditionChangeBeforeDeparturePenaltyAmount;
  penalty_currency?: OrderConditionChangeBeforeDeparturePenaltyCurrency;
}

export type OrderMetadataAnyOf = { [key: string]: any };

export type OrderMetadata = OrderMetadataAnyOf | null;

export type OrderTaxCurrency = string | null;

export type OrderSyncedAt = string | null;

export type OrderCancelledAt = string | null;

export type OrderBaseCurrency = string | null;

export type OrderBaseAmount = string | null;

/**
 * Once you've searched for flights by creating an offer request, and you've chosen
    which offer you want to book, you'll then want to create an order.

    To create an order, you just need to provide the offer ID, payment details and some
    additional information on the passengers (e.g. their full name and date of birth).
    
 */
export interface Order {
  id: string;
  live_mode: boolean;
  available_actions: string[];
  base_amount?: OrderBaseAmount;
  base_currency?: OrderBaseCurrency;
  booking_reference: string;
  cancelled_at?: OrderCancelledAt;
  content: string;
  created_at: string;
  synced_at?: OrderSyncedAt;
  documents: OrderDocument[];
  passengers: OrderPassenger[];
  payment_status: OrderPaymentStatus;
  services: DuffelApiModelsOrderOrderService[];
  slices: OrderSlice[];
  conditions: OrderConditions;
  owner: Airline;
  tax_amount: string;
  tax_currency?: OrderTaxCurrency;
  total_amount: string;
  total_currency: string;
  metadata?: OrderMetadata;
}

/**
 * The baggage allowances for the passenger on this segment included in the offer.
    Some airlines may allow additional baggage to be booked as a service - see the offer's
    `available_services`
    
 */
export interface OfferSliceSegmentPassengerBaggage {
  type: string;
  quantity: number;
}

export type OfferSliceSegmentPassengerFareBasisCode = string | null;

/**
 * Additional segment-specific information about the passengers included in the offer
    (e.g. their baggage allowance and the cabin class they will be travelling in)

    
 */
export interface OfferSliceSegmentPassenger {
  baggages: OfferSliceSegmentPassengerBaggage[];
  cabin_class: string;
  cabin_class_marketing_name: string;
  passenger_id: string;
  fare_basis_code?: OfferSliceSegmentPassengerFareBasisCode;
}

export type OfferSliceSegmentOperatingCarrierFlightNumber = string | null;

export type OfferSliceSegmentDuration = string | null;

export type OfferSliceSegmentDistance = string | null;

export type OfferSliceSegmentOriginTerminal = string | null;

export type OfferSliceSegmentDestinationTerminal = string | null;

export type OfferSliceSegmentAircraft = Aircraft | null;

/**
 * The segments - that is, specific flights - that the airline is offering
    to get the passengers from the `origin` to the `destination`
    
 */
export interface OfferSliceSegment {
  id: string;
  aircraft?: OfferSliceSegmentAircraft;
  arriving_at: string;
  departing_at: string;
  destination: Airport;
  destination_terminal?: OfferSliceSegmentDestinationTerminal;
  origin: Airport;
  origin_terminal?: OfferSliceSegmentOriginTerminal;
  distance?: OfferSliceSegmentDistance;
  duration?: OfferSliceSegmentDuration;
  marketing_carrier: Airline;
  marketing_carrier_flight_number: string;
  operating_carrier: Airline;
  operating_carrier_flight_number?: OfferSliceSegmentOperatingCarrierFlightNumber;
  passengers: OfferSliceSegmentPassenger[];
}

export type OfferSliceConditionsChangeBeforeDeparturePenaltyCurrency =
  | string
  | null;

export type OfferSliceConditionsChangeBeforeDeparturePenaltyAmount =
  | string
  | null;

/**
 * Whether this slice can be changed before the departure.

    If the slice can be changed for all of the passengers then
    the `allowed` property will be `true` and information will be
    provided about any penalties.

    If none of the passengers on the slice can be changed then
    the `allowed` property will be `false`.

    In all other cases this property will be `null` indicating we
    can't provide the information for this slice.

    The `penalty_amount` is specific to changing this slice and may not be
    the penalty that is applied if the entire offer is changed.
    
 */
export interface OfferSliceConditionsChangeBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OfferSliceConditionsChangeBeforeDeparturePenaltyAmount;
  penalty_currency?: OfferSliceConditionsChangeBeforeDeparturePenaltyCurrency;
}

export type OfferSliceConditionsChangeBeforeDepartureProperty =
  OfferSliceConditionsChangeBeforeDeparture | null;

/**
 * The conditions associated with this slice, describing the kinds of
    modifications you can make post-booking and any penalties that
    will apply to those modifications.

    This condition is applied only to this slice and to all the passengers
    associated with this offer - for information at the offer level
    (e.g. "what happens if I want to change all the slices?") refer to the
    `conditions` at the top level.

    If a particular kind of modification is allowed, you may not always be able to take
    action through the Duffel API. In some cases, you may need to contact the Duffel
    support team or the airline directly.
    
 */
export interface OfferSliceConditions {
  change_before_departure?: OfferSliceConditionsChangeBeforeDepartureProperty;
}

export type OfferSliceFareBrandName = string | null;

export type OfferSliceDuration = string | null;

export type OfferSliceOriginTerminal = string | null;

export type OfferSliceDestinationTerminal = string | null;

/**
 * Each slice will include one or more segments, the specific flights that the airline
    is offering to take the passengers from the slice's origin to its destination.
    
 */
export interface OfferSlice {
  id: string;
  destination: Place;
  destination_terminal?: OfferSliceDestinationTerminal;
  origin: Place;
  origin_terminal?: OfferSliceOriginTerminal;
  duration: OfferSliceDuration;
  fare_brand_name?: OfferSliceFareBrandName;
  segments: OfferSliceSegment[];
  conditions: OfferSliceConditions;
}

export type OfferRequestSliceOrigin = Airport | City;

export type OfferRequestSliceDestination = Airport | City;

/**
 * One-way journeys can be expressed using one slice, whereas return trips will need
    two.
    
 */
export interface OfferRequestSlice {
  destination_type: string;
  destination: OfferRequestSliceDestination;
  origin_type: string;
  origin: OfferRequestSliceOrigin;
  departure_date: string;
}

export type OfferRequestPassengerFamilyName = string | null;

export type OfferRequestPassengerGivenName = string | null;

export type OfferRequestPassengerType = string | null;

export type OfferRequestPassengerAge = number | null;

/**
 * The passengers who want to travel
 */
export interface OfferRequestPassenger {
  id: string;
  age: OfferRequestPassengerAge;
  type: OfferRequestPassengerType;
  given_name?: OfferRequestPassengerGivenName;
  family_name?: OfferRequestPassengerFamilyName;
  loyalty_programme_accounts: LoyaltyProgrammeAccount[];
}

export type OfferRequestCabinClass = string | null;

/**
 * To search for flights, you'll need to create an offer request. An offer request
    describes the passengers and where and when they want to travel (in the form of a
    list of slices). It may also include additional filters (e.g. a particular cabin to
    travel in).
    
 */
export interface OfferRequest {
  id: string;
  live_mode: boolean;
  cabin_class?: OfferRequestCabinClass;
  created_at: string;
  offers: Offer[];
  slices: OfferRequestSlice[];
  passengers: OfferRequestPassenger[];
}

export type OfferPassengerFamilyName = string | null;

export type OfferPassengerGivenName = string | null;

export type OfferPassengerType = string | null;

export type OfferPassengerAge = number | null;

/**
 * The passenger travelling
 */
export interface OfferPassenger {
  id: string;
  age?: OfferPassengerAge;
  type?: OfferPassengerType;
  given_name?: OfferPassengerGivenName;
  family_name?: OfferPassengerFamilyName;
  loyalty_programme_accounts: LoyaltyProgrammeAccount[];
}

/**
 * The conditions associated with this offer, describing the kinds of modifications
    you can make post-booking and any penalties that will apply to those modifications.
    
 */
export interface OfferConditions {
  change_before_departure?: OfferConditionsChangeBeforeDeparture;
  refund_before_departure?: OfferConditionsRefundBeforeDeparture;
}

export type OfferConditionRefundBeforeDeparturePenaltyCurrency = string | null;

export type OfferConditionRefundBeforeDeparturePenaltyAmount = string | null;

/**
 * Whether the whole offer can be refunded before the departure of the first slice.

    If all of the slices on the offer can be refunded then the allowed property will be
    true and information will be provided about any penalties. If any of the slices on the
    offer can't be refunded then the allowed property will be false. If the airline hasn't
    provided any information about whether this offer can be refunded then this property
    will be null.
    
 */
export interface OfferConditionRefundBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OfferConditionRefundBeforeDeparturePenaltyAmount;
  penalty_currency?: OfferConditionRefundBeforeDeparturePenaltyCurrency;
}

export type OfferConditionsRefundBeforeDeparture =
  OfferConditionRefundBeforeDeparture | null;

export type OfferConditionChangeBeforeDeparturePenaltyCurrency = string | null;

export type OfferConditionChangeBeforeDeparturePenaltyAmount = string | null;

/**
 * Whether the whole offer can be changed before the departure of the first slice.

    If all of the slices on the offer can be changed then the allowed property will be
    true. Refer to the slices for information about change penalties. If any of the slices
    on the offer can't be changed then the allowed property will be false. In this case
    you should refer to the slices conditions to determine if any part of the offer is
    changeable. If the airline hasn't provided any information about whether this offer
    can be changed then this property will be null.
    
 */
export interface OfferConditionChangeBeforeDeparture {
  allowed: boolean;
  penalty_amount?: OfferConditionChangeBeforeDeparturePenaltyAmount;
  penalty_currency?: OfferConditionChangeBeforeDeparturePenaltyCurrency;
}

export type OfferConditionsChangeBeforeDeparture =
  OfferConditionChangeBeforeDeparture | null;

export type OfferTaxCurrency = string | null;

export type OfferTaxAmount = string | null;

export type OfferAvailableServices = Service[] | null;

/**
 * After you've searched for flights by creating an offer request, we'll send your
    search to a range of airlines, which may return offers.

    Each offer represents flights you can buy from an airline at a particular price that
    meet your search criteria.

    You'll see slices inside the offers. Each slice will also include a list of one or
    more specific flights (called segments) that the airline is offering to get the
    passengers where they want to go.
    
 */
export interface Offer {
  id: string;
  live_mode: boolean;
  allowed_passenger_identity_document_types: string[];
  available_services?: OfferAvailableServices;
  base_amount: string;
  base_currency: string;
  conditions: OfferConditions;
  created_at: string;
  updated_at: string;
  expires_at: string;
  owner: Airline;
  partial: boolean;
  passenger_identity_documents_required: boolean;
  passengers: OfferPassenger[];
  payment_requirements: PaymentRequirements;
  slices: OfferSlice[];
  tax_amount?: OfferTaxAmount;
  tax_currency?: OfferTaxCurrency;
  total_emissions_kg: string;
  total_amount: string;
  total_currency: string;
}

/**
 * A passenger's loyalty programme account
 */
export interface LoyaltyProgrammeAccount {
  airline_iata_code: string;
  account_number: string;
}

export type ListOrdersInputWithPaginationPagination = PaginationInput | null;

/**
 * Whether to filter orders that are awaiting payment or not. If not specified, all orders regardless of their payment state will be returned.
 */
export type ListOrdersInputAwaitingPayment = boolean | null;

/**
 * The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section.
 */
export type ListOrdersInputLimit = number | null;

export interface ListOrdersInput {
  /** The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section. */
  limit?: ListOrdersInputLimit;
  /** Whether to filter orders that are awaiting payment or not. If not specified, all orders regardless of their payment state will be returned. */
  awaiting_payment: ListOrdersInputAwaitingPayment;
}

export interface ListOrdersInputWithPagination {
  pagination?: ListOrdersInputWithPaginationPagination;
  /** Actual request exluding pagination. */
  request: ListOrdersInput;
}

export type ListOffersInputWithPaginationPagination = PaginationInput | null;

export interface ListOffersInputWithPagination {
  pagination?: ListOffersInputWithPaginationPagination;
  /** Actual request exluding pagination. */
  request: ListOffersInput;
}

/**
 * By default, the offers will be returned sorted by ID in ascending order. This parameter allows you to sort the list of offers by total_amount or total_duration. By default the sorting order will be ascending, if you wish to sort in descending order a - will need to be prepended to the sorting attribute (i.e: -total_amount).
 */
export type ListOffersInputSort = SortValue | null;

/**
 * The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section.
 */
export type ListOffersInputLimit = number | null;

export interface ListOffersInput {
  /** The maximum number of records to return per page. Defaults to 50. May be set to any integer between 1 and 200. For more information on how to paginate through records, see the Pagination section. */
  limit?: ListOffersInputLimit;
  /** Duffel's unique identifier for the offer request, returned when it was created */
  offer_request_id: string;
  /** Allows to filter the offers list by the maximum number of connections in a given offer. e.g. a return flight with three flights outbound and a direct inbound flight would be filtered out if max_connections=1 was passed. */
  max_connections?: number;
  /** By default, the offers will be returned sorted by ID in ascending order. This parameter allows you to sort the list of offers by total_amount or total_duration. By default the sorting order will be ascending, if you wish to sort in descending order a - will need to be prepended to the sorting attribute (i.e: -total_amount). */
  sort?: ListOffersInputSort;
}

export type IdDocumentType =
  (typeof IdDocumentType)[keyof typeof IdDocumentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IdDocumentType = {
  passport: 'passport',
  tax_id: 'tax_id',
  known_traveler_number: 'known_traveler_number',
  passenger_redress_number: 'passenger_redress_number',
} as const;

export interface IdDocument {
  /** Must only be provided for passport type. The date on which the identity document expires */
  expires_on: string;
  /** Must only be provided for passport, known_traveler_number, and passenger_redress_number types. The ISO 3166-1 alpha-2 code of the country that issued this identity document. */
  issuing_country_code: string;
  /** The type of the identity document. Currently, the only supported types are passport, tax_id, known_traveler_number, and passenger_redress_number. The identity document's type supported by the airline can be found in the offer's supported_passenger_identity_document_types. */
  type: IdDocumentType;
  /** The unique identifier of the identity document. e.g. the passport number. */
  unique_identifier: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GetPartialOfferInput {
  /** To search for flights, you'll need to create an offer request. An offer request describes the passengers and where and when they want to travel (in the form of a list of slices). It may also include additional filters (e.g. a particular cabin to travel in). */
  data: _TypesDuffelApiGetPartialOfferInputData;
}

export type Gender = (typeof Gender)[keyof typeof Gender];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Gender = {
  M: 'M',
  F: 'F',
} as const;

export interface DepartureTimeRange {
  /** The local time in the format hh:mm of the origin airport at or after which the slice should depart. Defaults to current time at airport when only to is provided or from value is in the past */
  from: string;
  /** The local time in the format hh:mm of the origin airport at or before which the slice should depart. Defaults to 23:59 when only from is provided */
  to: string;
}

export interface CreatePaymentIntentInput {
  /** The amount of the payment. This should be the same as the total_amount of the offer specified in selected_offers, plus the total_amount of all the services specified in services. */
  amount: string;
  /** The currency of the amount, as an ISO 4217 currency code. This should be the same as the total_currency of the offer specified in selected_offers. The first two letters of the ISO 4217 three-letter code are the same as the code for the country name, and, where possible, the third letter corresponds to the first letter of the currency name */
  currency: string;
}

export interface CreateOrderInput {
  /** Metadata contains a set of key-value pairs that you can attach to an object. It can be useful for storing additional information about the object, in a structured format. Duffel does not use this information. You should not store sensitive information in this field.

The metadata is a collection of key-value pairs, both of which are strings. You can store a maximum of 50 key-value pairs, where each key has a maximum length of 40 characters and each value has a maximum length of 500 characters.

Keys must only contain numbers, letters, dashes, or underscores. */
  metadata?: RootModelDictAnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength40PydanticGeneralMetadataPatternAZAZ09AnnotatedStrFieldInfoAnnotationNoneTypeRequiredTrueMetadataMaxLenMaxLength500;
  passengers: _TypesDuffelApiCreateOrderInputPassengers;
  payments: Payments;
  /** The ids of the offers you want to book. You must specify an array containing exactly one selected offer.

Note that you can only book one offer per offer request. */
  selected_offers: string[];
  services: OrderServices;
  /** The type of order. You can only use hold with offers where payment_requirements.requires_instant_payment is false.

When booking an offer with type hold, do not specify payments or services keys. */
  type: OrderType;
}

export interface ConfirmPaymentIntentInput {
  /** Duffel's unique identifier for the resource */
  id: string;
}

/**
 * The metropolitan area where the airport is located.
    Only present for airports which are registered with IATA as
    belonging to a metropolitan area.
    
 */
export interface City {
  id: string;
  name: string;
  iata_code: string;
  iata_country_code: string;
}

export type CabinClass = (typeof CabinClass)[keyof typeof CabinClass];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CabinClass = {
  first: 'first',
  business: 'business',
  premium_economy: 'premium_economy',
  economy: 'economy',
} as const;

export interface ArrivalTimeRange {
  /** The local time in the format hh:mm of the destination airport at or after which the slice should arrive. Defaults to 00:00 when only to is provided */
  from: string;
  /** The local time in the format hh:mm of the destination airport at or before which the slice should arrive. Defaults to 23:59 when only from is provided */
  to: string;
}

export type AirportCity = City | null;

export type AirportIcaoCode = string | null;

export type AirportIataCode = string | null;

/**
 * Airports are used to identify origins and destinations in journey
    slices
 */
export interface Airport {
  id: string;
  name: string;
  iata_code?: AirportIataCode;
  icao_code?: AirportIcaoCode;
  iata_country_code: string;
  latitude: number;
  longitude: number;
  time_zone: string;
  city?: AirportCity;
}

export type AirlineIataCode = string | null;

/**
 * Airlines are used to identify the air travel companies selling and operating
    flights
    
 */
export interface Airline {
  id: string;
  name: string;
  iata_code?: AirlineIataCode;
}

/**
 * Aircraft are used to describe what passengers will fly in for a given trip
 */
export interface Aircraft {
  id: string;
  iata_code: string;
  name: string;
}

/**
 * To search for flights, you'll need to create an offer request. An offer request describes the passengers and where and when they want to travel (in the form of a list of slices). It may also include additional filters (e.g. a particular cabin to travel in).

We'll send your search to a range of airlines, and return your offer request back to you with a series of offers.

Each offer represents a set of flights you can buy from an airline at a particular price that meet your search criteria.

Inside the offers, you'll see your slices, but now each slice will also include a list of one or more specific flights (called segments) that the airline is offering to get the passengers where they want to go.

When presenting offers to your customers, you should always show the full name of the operating carrier of each segment (slices[].segments[].operating_carrier.name). This must be displayed prominently on the first screen where the offer is presented in order to comply with US regulations.
 * @summary Search
 */
export const flightSearch = <TData = AxiosResponse<OfferRequest>,>(
  searchInput: SearchInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/flight/search`, searchInput, options);
};

/**
 * To search for and select flights separately for each slice of the journey, you'll
need to create a partial offer reques. A partial offer request describes the
passengers and where and when they want to travel (in the form of a list of
slices). It may also include additional filters (e.g. a particular cabin to
travel in).
 * @summary Create Partial Offer Requests
 */
export const flightCreatePartialOfferRequests = <
  TData = AxiosResponse<OfferRequest>,
>(
  searchInput: SearchInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/create-partial-offer-request`,
    searchInput,
    options
  );
};

/**
 * Retrieves a partial offers request by its ID, only including partial offers for the current slice of 
multi-step search flow.
In order to view partial offers for the second slice of the itinerary, you need to provide the selected 
partial offer ID from the results of creating a partial offer request (which is considered the first 
slice of the journey).

For a multi-city search you might need to provide more than one selected partial offer ID. For example, 
when retrieving partial offers for the third slice, you need to provide selected partial offer IDs of two 
previous slices.
 * @summary Get Partial Offer Requests
 */
export const flightGetPartialOfferRequests = <
  TData = AxiosResponse<OfferRequest>,
>(
  getPartialOfferInput: GetPartialOfferInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/get-partial-offer-request`,
    getPartialOfferInput,
    options
  );
};

/**
 * Retrieves a partial offers request by its ID, only including partial offers for the current slice of 
multi-step search flow.
In order to view partial offers for the second slice of the itinerary, you need to provide the selected 
partial offer ID from the results of creating a partial offer request (which is considered the first 
slice of the journey).

For a multi-city search you might need to provide more than one selected partial offer ID. For example, 
when retrieving partial offers for the third slice, you need to provide selected partial offer IDs of two 
previous slices.
 * @summary Get Partial Offer Requests Fares
 */
export const flightGetPartialOfferRequestsFares = <
  TData = AxiosResponse<OfferRequest>,
>(
  getPartialOfferInput: GetPartialOfferInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/get-partial-offer-request-fares`,
    getPartialOfferInput,
    options
  );
};

/**
 * Retrieves a list of offers for a given offer request specified by its ID. Unless you specify a sort parameter, the results may be returned in any order.

This endpoint does not return the complete, up-to-date information on each offer. The Get a single offer endpoint should be called for a given offer in order to get complete and up-to-date information.
 * @summary List Offers
 */
export const flightListOffers = <TData = AxiosResponse<PaginatedResultOffer>,>(
  listOffersInputWithPagination: ListOffersInputWithPagination,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/list-offers`,
    listOffersInputWithPagination,
    options
  );
};

/**
 * @summary Select Offer
 */
export const flightSelectOffer = <TData = AxiosResponse<Offer>,>(
  offerId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/flight/select-offer/${offerId}`, options);
};

/**
 * To begin the process of collecting a card payment from your customer, you
need to create a Payment Intent.

The Payment Intent will contain a client_token that you use to collect the
card payment in your application.

If the Payment Intent is created in test mode you should use a test card.
 * @summary Create Payment Intent
 */
export const flightCreatePaymentIntent = <
  TData = AxiosResponse<PaymentIntent>,
>(
  createPaymentIntentInput: CreatePaymentIntentInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/create-payment-intent`,
    createPaymentIntentInput,
    options
  );
};

/**
 * Once you've successfully collected the customer's card details, using the client_token from when you
first created the Payment Intent, you then need to confirm it using this endpoint.

Once confirmed, the amount charged to your customer's card will be added to your balance
(minus any Duffel Payment fees). Attempting to confirm it more than once will have no effect.
 * @summary Confirm Payment Intent
 */
export const flightConfirmPaymentIntent = <
  TData = AxiosResponse<PaymentIntent>,
>(
  confirmPaymentIntentInput: ConfirmPaymentIntentInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/confirm-payment-intent`,
    confirmPaymentIntentInput,
    options
  );
};

/**
 * Once you've searched for flights by creating an offer request, and you've chosen which offer you want to book, you'll then want to create an order.

To create an order, you just need to provide the offer ID, payment details and some additional information on the passengers (e.g. their full name and date of birth).

This endpoint creates a booking with an airline based on an offer.

Orders are usually paid at the time of creation, but can be held, and paid for at a later date if the offer supports it (see offer.payment_requirements.requires_instant_payment).

To create an order and pay for it at the same time, specify a payments key with an appropriate value. Also, specify the type key with a value of "instant".

To hold the order and pay for it later, specify the type as "hold", omit the payments and services keys. You'll then need to complete payment after creating the order through the Create a payment endpoint.

Airlines limit the number of passengers in a single order to ‚â§ 9.

When presenting an order confirmation to your customers (e.g. on screen or in an email), you should include the booking_reference and details of the full itinerary and show the full name of the operating carrier of each segment (slices[].segments[].operating_carrier.name) in order to comply with US regulations.
 * @summary Create Order
 */
export const flightCreateOrder = <TData = AxiosResponse<Order>,>(
  createOrderInput: CreateOrderInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/flight/create-order`, createOrderInput, options);
};

/**
 * Some order fields are updateable. Each field that can be updated is detailed in the request object.
 * @summary Update Order
 */
export const flightUpdateOrder = <TData = AxiosResponse<Order>,>(
  orderId: string,
  updateOrderInput: UpdateOrderInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/update-order/${orderId}`,
    updateOrderInput,
    options
  );
};

/**
 * Some order fields are updateable. Each field that can be updated is detailed in the request object.
 * @summary List Places
 */
export const flightListPlaces = <TData = AxiosResponse<Places>,>(
  searchPlacesInput: SearchPlacesInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/flight/list-places`, searchPlacesInput, options);
};

/**
 * Some order fields are updateable. Each field that can be updated is detailed in the request object.
 * @summary List Airports
 */
export const flightListAirports = <
  TData = AxiosResponse<PaginatedResultAirport>,
>(
  searchAirportInputWithPagination: SearchAirportInputWithPagination,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/list-airports`,
    searchAirportInputWithPagination,
    options
  );
};

/**
 * Some order fields are updateable. Each field that can be updated is detailed in the request object.
 * @summary List Orders
 */
export const flightListOrders = <TData = AxiosResponse<PaginatedResultOrder>,>(
  listOrdersInputWithPagination: ListOrdersInputWithPagination,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/flight/list-orders`,
    listOrdersInputWithPagination,
    options
  );
};

/**
 * @summary Get Order
 */
export const flightGetOrder = <TData = AxiosResponse<Order>,>(
  orderId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/flight/get-order/${orderId}`, undefined, options);
};

/**
 * @summary Root
 */
export const systemRoot = <TData = AxiosResponse<unknown>,>(
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/`, options);
};

/**
 * @summary Health Check
 */
export const systemHealthCheck = <TData = AxiosResponse<unknown>,>(
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/healthz`, options);
};

export type FlightSearchResult = AxiosResponse<OfferRequest>;
export type FlightCreatePartialOfferRequestsResult =
  AxiosResponse<OfferRequest>;
export type FlightGetPartialOfferRequestsResult = AxiosResponse<OfferRequest>;
export type FlightGetPartialOfferRequestsFaresResult =
  AxiosResponse<OfferRequest>;
export type FlightListOffersResult = AxiosResponse<PaginatedResultOffer>;
export type FlightSelectOfferResult = AxiosResponse<Offer>;
export type FlightCreatePaymentIntentResult = AxiosResponse<PaymentIntent>;
export type FlightConfirmPaymentIntentResult = AxiosResponse<PaymentIntent>;
export type FlightCreateOrderResult = AxiosResponse<Order>;
export type FlightUpdateOrderResult = AxiosResponse<Order>;
export type FlightListPlacesResult = AxiosResponse<Places>;
export type FlightListAirportsResult = AxiosResponse<PaginatedResultAirport>;
export type FlightListOrdersResult = AxiosResponse<PaginatedResultOrder>;
export type FlightGetOrderResult = AxiosResponse<Order>;
export type SystemRootResult = AxiosResponse<unknown>;
export type SystemHealthCheckResult = AxiosResponse<unknown>;
